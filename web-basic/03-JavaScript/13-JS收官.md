# BOM

[https://www.w3school.com.cn/jsref/dom_obj_window.asp](https://www.w3school.com.cn/jsref/dom_obj_window.asp)

## 什么是BOM？

BOM是browser object model的缩写，简称浏览器对象模型。

主要处理浏览器窗口（window）和框架（iframe），描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。

**扩展如下：**

> 1.弹出新的浏览器窗口
> 2.移动、关闭浏览器窗口以及调整窗口大小3.提供 Web 浏览器详细信息的定位对象
> 4.提供用户屏幕分辨率详细信息的屏幕对象
>
> 5.对 cookie 的支持
>
> 6.IE 扩展了BOM，加入了ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象

## BOM核心window

window对象是BOM的顶层(核心)对象，玩转BOM，就是玩转window的属性和方法。

Window对象它具有双重角色，既是通过js访问浏览器窗口的一个接口，又是一个全局对象。这意味着在网页中定义的任何对象，变量和函数，都是window的属性。

## BOM 和DOM的关系

> JavaScript语法的标准化组织是ECMA。
>
> DOM的标准化组织是W3C。
>
> BOM…(很尴尬)

![image.png](../.gitbook/assets/1594818538240-7a8f52d5-6d89-47cb-8947-a31d4da4341c.png)

## BOM的组成

Window： JavaScript 层级中的顶层对象表示浏览器窗口。

Navigator：包含客户端浏览器的信息。

History： 包含了浏览器窗口访问过的URL。

Location： 包含了当前 URL 的信息。

Screen： 包含客户端显示屏的信息。兼容性太差，用的很少。

# BOM对象

## Window

Window： JavaScript 层级中的顶层对象表示浏览器窗口。

### window 对象属性

history

对 History 对象的只读引用。请参数 History 对象。

innerheight

返回窗口的文档显示区的高度。

innerwidth

返回窗口的文档显示区的宽度。

location

用于窗口或框架的 Location 对象。请参阅 Location 对象。

Navigator

对 Navigator 对象的只读引用。请参数 Navigator 对象。

pageXOffset

设置或返回当前页面相对于窗口显示区左上角的 X 位置。

pageYOffset

设置或返回当前页面相对于窗口显示区左上角的 Y 位置。

parent

返回父窗口。

Screen

对 Screen 对象的只读引用。请参数 Screen 对象。

top

返回最顶层的先辈窗口。

screenLeft screenTop screenX screenY

只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。IE、Safari、Chrome 和 Opera 支持 screenLeft和 screenTop，而 Chrome、Firefox 和 Safari 支持 screenX 和 screenY。

### window 对象方法

alert()

显示带有一段消息和一个确认按钮的警告框。

clearInterval()

取消由 setInterval() 设置的 timeout。

clearTimeout()

取消由 setTimeout() 方法设置的 timeout。

close()

关闭浏览器窗口。

confirm()

显示带有一段消息以及确认按钮和取消按钮的对话框。返回值：true,false

open()

打开一个新的浏览器窗口或查找一个已命名的窗口。window.open(URL,name,features,replace)

prompt()

显示可提示用户输入的对话框。

scrollBy()

按照指定的像素值来滚动内容。

scrollTo()

把内容滚动到指定的坐标。

setInterval()

按照指定的周期(以毫秒计)来调用函数或计算表达式。

setTimeout()

在指定的毫秒数后调用函数或计算表达式。

**案例：**图片懒加载模拟。

    <body>
        <div style="width: 200px; height: 200px; background-color: #f40; opacity: 0.3; margin: 1000px auto;"></div>
        <script>
            // offsetTop    元素距顶部
            // window.pageYoffset   纵向滚动距离
            // window.innerHeight   可视区高度
            var oDiv = document.getElementsByTagName('div')[0];
    
            document.addEventListener('scroll',demo);
            function demo() {
                if ( oDiv.offsetTop <= window.pageYOffset + window.innerHeight) {
                    var timer = setInterval(function() {
                        if (oDiv.style.opacity == '1') {
                            clearInterval(timer);
                        } else {
                            oDiv.style.opacity = parseFloat(oDiv.style.opacity) + 0.01;
                            console.log(oDiv.style.opacity);
                        }
                    },90)
                } else {
                    oDiv.style.opacity = 0.3;
                }
            }
        </script>
    </body>

**案例：open()**

> 返回值wIndow。

    // 新弹出窗口 
    window.open('https://www.baidu.com','duyi','width=400,height=200');
    
    // 新标签打开
    window.open('https://www.baidu.com');

## Navigator

## History

### History 对象属性、方法

length

返回浏览器历史列表中的 URL 数量。

back()

加载 history 列表中的前一个 URL。

forward()

加载 history 列表中的下一个 URL。

go()

加载 history 列表中的某个具体页面。

## Location

    //url
    
    //协议
    // https://
    
    // //域名
    // www.baidu.com:443
    // //路径
    // /s 
    
    // //参数
    // ?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=nba&rsv_pq=b07bc8ac00008677&rsv_t=6332vNWuKAWk0z%2Be3i0Us%2Fy57isnFUgi5BkSHV66DDbmlHqv%2B4z3clPFJwY&rqlang=cn&rsv_enter=1&rsv_sug3=3&rsv_sug1=3&rsv_sug7=100&rsv_sug2=0&inputT=448&rsv_sug4=448
    // //锚点
    // #dasdas

### Location 对象属性

hash

设置或返回从井号 (#) 开始的 URL(锚)。

host

设置或返回主机名和当前 URL 的端口号。

href

设置或返回完整的 URL。

pathname

设置或返回当前 URL 的路径部分。

protocol

设置或返回当前 URL 的协议。

search

设置或返回从问号 (?) 开始的 URL(查询部分)。

### Location 对象方法

属性描述[assign()](https://www.w3school.com.cn/jsref/met_loc_assign.asp)加载新的文档。[reload()](https://www.w3school.com.cn/jsref/met_loc_reload.asp)重新加载当前文档。[replace()](https://www.w3school.com.cn/jsref/met_loc_replace.asp)用新的文档替换当前文档。

## Screen

### Screen 对象属性

assign()

加载新的文档。

reload(‘force’)

重新加载当前文档。参数可选，不填或填 false 则取浏览器缓存的文档

replace()

用新的文档替换当前文档。



# 浏览器基本组成

**浏览器请求页面大致经历了哪些过程?**

> 1. 发送url：DNS查询，请求IP地址
>
> 2. TCP三次握手
>
> 3. 服务器响应内容
>
> 4. 按照成哥讲的js时间线理解js解析执行的过程就好
>
> 5. 渲染页面： DOM树 CSSDOM树，生成RENDER树，布局，渲染
>
> 6. TCP四次挥手

**浏览器基本组成：**

> 1. 用户界面
> 2. 浏览器引擎
> 3. 渲染引擎：(html、css渲染）
> 4. 网络
> 5. UI后端
> 6. Js引擎：
> 7. 数据存储：提供持久化缓存。

![image.png](../.gitbook/assets/1594855653039-c8ff75be-8c48-4c80-b74b-f09318f9c0d5.png)

# 渲染引擎-渲染模式

**渲染引擎，渲染过程？**

> 渲染引擎: 
>
> 其职责就是渲染，即在浏览器窗口中显示所请求的内容。
> 过程：解析html从而构建DOM树->CSS Rule 树->构建Render树->布局Render树->绘制Render树。

![image.png](../.gitbook/assets/1594855703256-c16aa352-28ef-4597-ba81-6d8ae1329372.png)

**渲染模式的历史意义？**

在多年以前（IE6诞生以前），各浏览器都处于各自比较封闭的发展中（基本没有兼容性可谈）。

随着WEB的发展，兼容性问题的解决越来越显得迫切，随即，各浏览器厂商发布了按照标准模式（遵循各厂商制定的统一标准）工作的浏览器，比如IE6就是其中之一。

但是考虑到以前建设的网站并不支持标准模式，所以各浏览器在加入标准模式的同时也保留了混杂模式（即以前那种未按照统一标准工作的模式，也叫怪异模式）。

**渲染模式如何控制？**

> 三种标准模式的写法。

    1.<!DOCTYPE html>
    
    2.<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
    
    3.<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

# 查漏补缺

## Label标签

绑定在一起，一体化。

**案例：**绑定label和input，点击文字获得焦点。

    <body>
        <label for="demo">username</label>
        <input type="text" id="demo">
    </body>

## 属性和特性

属性包含特性。

> 特性：type、value、id、class。DOM 对象 === input 一一映射关系，可以通过`domEle.prop`访问。
>
> 
>
>
> 属性：data。自定义的。`domEle.prop`获取不到，只能通过`getAttribute()`获取。
>
> 通过`setAttriute()`设置的属性，只能通过`getAttribute()`获取。

    <body>
        <input type="text" value="aaa" id="demo" data="duyi" ss="ss">
        <script>
            var oInput = document.getElementsByTagName('input')[0];
            // DOM 对象 === input 一一映射关系，可以通过domEle.prop访问。
            console.log(oInput);
            console.log(oInput.type);
            console.log(oInput.value);
            console.log(oInput.id);
    
            // 自定义的。domEle.prop 获取不到
            console.log(oInput.data);       // undefined
    
            // setAttribute() 设置的属性只能通过getAttribute()获取
            oInput.setAttribute('oSet','oSet');
            console.log(oInput.oSet);                   // undefined
            console.log(oInput.getAttribute('oSet'));
    
        </script>
    </body>

## 图片预加载和懒加载

懒加载：按需加载。到那再加载。

预加载：提前加载。加载完成才显示。

**案例：**预加载

    <body>
        <div id="demo" style="width: 400px;height: 400px;border: 1px solid #ccc;"></div>    
        <script>      
            var oDiv = document.getElementById('demo');
            // var oImg = document.crateElement('img');
            var oImg = new Image();
            oImg.src = 'http://i2.wp.com/clutch.hk/wp-content/uploads/2015/05/hawks-cavaliers-g1.jpg?resize=1200%2C788'
            // 图片加载完成，才展示
            oImg.onload = function() {
                oDiv.appendChild(this);
            }
        </script>
    </body>

**案例：**淘宝图片预加载+懒加载

> **懒加载：**监控滑轮事件，不断判断当前的位置
>
> 到达位置时，采取**预加载：**图片加载完成后， 把图片正式的添加到页面之中。

    <body style="height: 2000px;">
        <div id='wrapper' style="position: absolute; top: 1500px;"></div>   
        <script>   
            var wrapper = document.getElementById('wrapper'); 
    
            // 1. 淘宝 图片预加载+懒加载
            // 将预加载函数定义在div元素的原型上
            HTMLDivElement.prototype.checkSelf = function() {
                if ( !this.lock) {
                    if (this.offsetTop < window.pageYOffset + window.innerHeight) {
                        // 加锁，防止加载多张图片
                        this.lock = true;
    
                        // 延时1000ms显示，不延时1000，加载完成即立即显示。
                        console.log('开始预加载。。。');
                        setTimeout(function() {
                            var oImg = new Image();
                            oImg.src = 'http://i2.wp.com/clutch.hk/wp-content/uploads/2015/05/hawks-cavaliers-g1.jpg?resize=1200%2C788';
                            // img 预加载完成，div添加
                            oImg.onload = function() {
                                wrapper.appendChild(this);
                            }
                        },1000)
                    }
                }
            }
    
            // 滚动事件
            window.onscroll = function() {
                wrapper.checkSelf();
            }
        </script>
    </body>

## Math.random() 应用

> `[0,1)` 区间。

    				// 取12-36的随机数
            //  12-36     36-12=24   24 * Math.random() -> [0, 24)  再加 12    
    				12 + 24 * Math.random() -> [12, 36)

## 文档碎片-虚拟DOM

> **1.文档碎片：**
>
> `docuemnt.createDocumentFragment();`
> 集中操作减少布局计算（重排）和绘制次数（重绘）。后期并不常用，效率低。
>
> 
>
> **2.字符串拼接：**
>
> 字符串拼接的方式，`innerHTML = htmlStr;` 当前阶段建议使用。

> **3.虚拟DOM：**
>
> 操作DOM成本高，所以可以采用虚拟DOM来搞定。

**文档碎片：**

    var oF = document.createDocumentFragment();
    var oUl = 
     for (var i = 0 ;i < 10; i ++） {
          var newLi = document.createElement('li');
    			newLi.innerText = i + '';
    		  oF.appendChild(newLi);		// 缓存起来。
          
          }
      oUl .appdendChild(oF);

**字符串拼接：**

> innerHTML()。

    var htmlStr = '';
    var oUl = 
     for (var i = 0 ;i < 10; i ++） {
          htmlStr += '<li>' + i + '</li';
          
          }
    oUl.innerHTML = htmlstr;

**虚拟DOM：**

> 后期源码阶段。

## 断点调试

> `debugger`

## 封装getElementsByClassName

**案例1：**

> 封装兼容性 `document.getElementsByClassName('demo');`

    <body>
        <div class="wrapper" id='ow'>
            <p class='    demo   active   box    '>
                <span class='   active   '></span>
                <span class='demo  box'></span>
            </p>
            <p class='demo'>
                <span class='   demo    active'></span>
            </p>
        </div>  
        <script>   
            Document.prototype.getElementsByClassName = function (_className) {
                var allDomArr = document.getElementsByTagName('*');
                var newDomArr = [];
                // 1或多个空格
                var reg = /\s+/g;
    
                for ( var i = 0; i < allDomArr.length; i ++) {
                    // 获取dom.className ，替换多余空格
                    var strClassName = allDomArr[i].className.replace(reg,' ').trim();
                    // 字符串按空格分隔
                    var tempArr = strClassName.split(' ');
                    for (var j = 0; j < tempArr.length; j ++) {
                      // className 不会重复，匹配到就break
                        if ( tempArr[j] == _className) {
                            console.log(tempArr[j]);
                            newDomArr.push(allDomArr[i]);
                            break;
                        }
                    }
                }
                return newDomArr;
            }
    
            var arrs = document.getElementsByClassName('demo');
            
        </script>
    </body>

**案例2：**

> 封装兼容性 `element.getElementsByClassName('demo');`

    <body>
        <div class="wrapper" id='ow'>
            <p class='    demo   active   box    '>
                <span class=' demo  active   '></span>
                <span class='demo2  box'></span>
                <i class='demo box2'></i>
            </p>
            <p class='demo'>
                <span class='   demo    active'></span>
            </p>
        </div>  
        <script>   
            Element.prototype.getElementsByClassName = Element.prototype.getElementsByClassName || function (_className) {
                console.log(this);
                var allDomArr = this.children;
                console.log(allDomArr);
                var newDomArr = [];
                // 1或多个空格
                var reg = /\s+/g;
    
                for ( var i = 0; i < allDomArr.length; i ++) {
                    // 获取dom.className ，替换多余空格
                    var strClassName = allDomArr[i].className.replace(reg,' ').trim();
                    // 字符串按空格分隔
                    var tempArr = strClassName.split(' ');
                    for (var j = 0; j < tempArr.length; j ++) {
                        // className 不会重复，匹配到就break
                        if ( tempArr[j] == _className) {
                            console.log(tempArr[j]);
                            newDomArr.push(allDomArr[i]);
                            break;
                        }
                    }
                }
                return newDomArr;
            }
    
            var box = document.getElementsByClassName('box')[0];
            var arrs = box.getElementsByClassName('demo');
        </script>
    </body>



# JavaScript运动 

# 案例

## 匀速运动

> 匀速运动停在目标点。

    <body>
        <div style="width: 100px; height: 100px; background-color: #F40; position: absolute;left: 0px; "></div>
        <button style="margin-top: 140px;">run</button>
        <span style="position: absolute; left: 500px; width: 1px; height: 100px; background-color: #000;"></span>
    
        <script>
            var oDiv = document.getElementsByTagName('div')[0];
            var oBtn = document.getElementsByTagName('button')[0];
            var timer = null;
            oBtn.onclick = function() {
                var iSpeed = 500 - parseInt(oDiv.style.left) > 0 ? 7 : -7;
                clearInterval(timer);
                timer = setInterval(function() {
                    if (Math.abs(500 - parseInt(oDiv.style.left)) < Math.abs(iSpeed)) {
                        oDiv.style.left = 500 + 'px';
                        clearInterval(timer);
                    } else {
                        oDiv.style.left = parseInt(oDiv.style.left) +  iSpeed + 'px';
                    }
                },30)
            }
        </script>
    </body>

**封装：**

    <body>
        <div style="width: 100px; height: 100px; background-color: #F40; position: absolute;left: 0px;"></div>
        <div style="width: 100px; height: 100px; background-color: #f80; position: absolute;left: 1000px;"></div>
        <button style="margin-top: 140px;">向右运动</button>
        <button style="margin-top: 140px;">向左运动</button>
    
        <span style="position: absolute; left: 500px; width: 1px; height: 100px; background-color: #000;"></span>
    
        <script>
            var oDivL = document.getElementsByTagName('div')[0];
            var oDivR = document.getElementsByTagName('div')[1];
            var oBtnL = document.getElementsByTagName('button')[0];
            var oBtnR = document.getElementsByTagName('button')[1];
    
            var timer = null;
    
            oBtnL.onclick = function() {
                startMove(oDivL, 500);
            }
            oBtnR.onclick = function() {
                startMove(oDivR, 500);             
            }
            // 封装匀速运动
            function startMove(domEle, target) {
                console.log(domEle.style.left);
                var iSpeed = target - parseInt(domEle.style.left) > 0 ? 7 : -7;
                clearInterval(timer);
                timer = setInterval(function() {
                    if (Math.abs(target - parseInt(domEle.style.left)) < Math.abs(iSpeed)) {
                        domEle.style.left = target + 'px';
                        // clearInterval(timer);
                    } else {
                        domEle.style.left = parseInt(domEle.style.left) +  iSpeed + 'px';
                    }
                },30)
            }
        </script>
    </body>

## 缓冲运动

    <body>
        <div class="wrapper" style="position: absolute; top: 300px; left: -400px; width: 450px; height: 50px; background-color: #f90;"> 
            <span style="position: absolute;right: 0;  width: 50px; height: 50px; background-color: #F40;"></span>
        </div>
        <script>
            var oDiv = document.getElementsByTagName('div')[0];
            var oSpan = document.getElementsByTagName('span')[0];
            var timer = null;
    
            oDiv.onmouseenter = function() {
                slowMove(this, 0);
            }
            oDiv.onmouseleave = function(e) {
                slowMove(this, -400);
            }
    
            // 封装缓速运动
            function slowMove(domEle, target) {
                clearInterval(timer);
                var iSpeed = null;
                timer = setInterval(function() {
                    iSpeed = (target - domEle.offsetLeft) / 7;
                    iSpeed = iSpeed > 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed);
                    console.log(iSpeed);
    
                    if (target == domEle.offsetLeft) {
                        clearInterval(timer);
                        console.log('aa');
                    } else {
                        domEle.style.left = domEle.offsetLeft + iSpeed + 'px';
                    }
                },30);
            }
        </script>
    </body>

案例：缓动透明度

    <body>
        <div class="wrapper" style="position: absolute; top: 100px; width: 200px; height: 200px; background-color: #f90; opacity: 0.3"> 
        </div>
        <script>
            var oDiv = document.getElementsByTagName('div')[0];
            var timer = null;
            oDiv.onmouseenter = function() {
                // 透明度opacity 也扩大100
                slowMove(this, 50);
            }
            // 封装缓速透明度函数
            function slowMove(domEle, target) {
                clearInterval(timer);
                var iSpeed = null;
                var iCur = null;
                timer = setInterval(function() {
                    // 扩大100
                    iCur = parseFloat(getStyle(domEle, 'opacity')) * 100;
                    iSpeed = (target - iCur) / 7 ;
                    iSpeed = iSpeed > 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed);
                    if (target == iCur) {
                        clearInterval(timer);
                    } else {
                        // opacity： 0-1 ，iCur * 100 target * 100 iCur + iSpeed 0-100 / 100
                        domEle.style.opacity = (iCur + iSpeed) / 100;
                    }
                },60);
            }
    
            function getStyle(dom, attr) {
                if (window.getComputedStyle) {
                    return window.getComputedStyle(dom, null)[attr];
                } else {
                    return dom.currentStyle[attr]
                }
            }
        </script>
    </body>

## 多物体运动

> 注意：给每个div生成一个定时器 

    <body>
        <div style="width: 100px; height: 100px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
        <div style="width: 100px; height: 100px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
        <div style="width: 100px; height: 100px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
        <div style="width: 100px; height: 100px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
        <div style="width: 100px; height: 100px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
        <script>
            var oDivArray = document.getElementsByTagName('div');
            var timer = null;
            for (var i = 0; i < oDivArray.length; i++) {
                oDivArray[i].onmouseenter = function() {
                    slowMove(this, 500);
                }
    
                oDivArray[i].onmouseleave = function() {
                    slowMove(this, 100);
                }
            }
    
            // 封装缓速宽度变化
            function slowMove(domEle, target) {
                clearInterval(domEle.timer);
                var iSpeed = null;
                var iCur = null;
                // 给标签添加一个属性
                domEle.timer = setInterval(function() {
                    // 扩大100
                    iCur = parseFloat(getStyle(domEle, 'width')) ;
                    iSpeed = (target - iCur) / 7 ;
                    iSpeed = iSpeed > 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed);
                    if (target == iCur) {
                        clearInterval(domEle.timer);
                    } else {
                        domEle.style.width = iCur + iSpeed + 'px';
                    }
                },60);
            }
    
            function getStyle(dom, attr) {
                if (window.getComputedStyle) {
                    return window.getComputedStyle(dom, null)[attr];
                } else {
                    return dom.currentStyle[attr]
                }
            }
        </script>
    </body>

## 多物体多值运动

多物体不同值运动

    <body>
        <div style="width: 100px; height: 100px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
        <div style="width: 100px; height: 100px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
        <div style="width: 100px; height: 100px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
        <script>
            var oDivArray = document.getElementsByTagName('div');
            var timer = null;
            oDivArray[0].onmouseenter = function() {
                slowMove(this, 'width', 500);
            }
    
            oDivArray[1].onmouseenter = function() {
                slowMove(this, 'opacity', 100);
            }
            oDivArray[2].onmouseenter = function() {
                slowMove(this, 'height', 500);
            }
    
            // 封装缓速宽度变化
            function slowMove(domEle, attr, target) {
                clearInterval(domEle.timer);
                var iSpeed = null;
                var iCur = null;
                // 给标签添加一个属性
                domEle.timer = setInterval(function() {
                    // oapcity扩大100
                    if (attr == 'opacity') {
                        iCur = parseFloat(getStyle(domEle, attr)) * 100 ;
                    } else {
                        iCur = parseInt(getStyle(domEle, attr)) ;
                    }
                    iSpeed = (target - iCur) / 7 ;
                    iSpeed = iSpeed > 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed);
    
                    if (target == iCur) {
                        clearInterval(domEle.timer);
                    } 
                    if (attr == 'opacity') {
                        domEle.style[attr] = (iCur + iSpeed) / 100 ;
    
                    } else {
                        domEle.style[attr] = iCur + iSpeed + 'px';
                    }
                },60);
            }
    
            function getStyle(dom, attr) {
                if (window.getComputedStyle) {
                    return window.getComputedStyle(dom, null)[attr];
                } else {
                    return dom.currentStyle[attr]
                }
            }
        </script>
    </body>

**多物体多值运动：**

    <body>
        <div style="position: absolute; left: 0; top: 0; width: 50px; height: 50px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
    
        <div style="position: absolute; left: 0; top: 500px; width: 50px; height: 50px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
    
        <script>
            var oDiv = document.getElementsByTagName('div')[0];
            var timer = null;
            // width： 50 -> 200; height: 50 -> 200;opacity: 0.5 -> 0.8; left: 0 -> 400; top: 0 -> 200
            var attrObj = {
                width: 200,
                height: 200,
                opacity: 80,        // 扩大100倍
                left: 400,
                top: 200
            }
            oDiv.onmouseenter = function() {
                slowMove(this, attrObj);
            }


​    

            // 封装多值运动
            function slowMove(domEle, attrObj) {
                clearInterval(domEle.timer);
                var iSpeed = null,
                    iCur = null,
                    target = null,
                    bStop = true;   // 停止条件标志
                
                // 给标签添加一个属性
                domEle.timer = setInterval(function() {
                    for ( var attr in attrObj) {
                        console.log(attr, typeof attr);
                        // oapcity扩大100
                        if (attr == 'opacity') {
                            iCur = parseFloat(getStyle(domEle, attr)) * 100 ;
                        } else {
                            iCur = parseInt(getStyle(domEle, attr)) ;
                        }
    
                        target = attrObj[attr];
                        iSpeed = (target - iCur) / 7 ;
                        iSpeed = iSpeed > 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed);
    
                        if (target != iCur) {
                            bStop = false;          // 有一个没有到达目标点，bStop 为false，不能清理定时器
                        } 
                        if (attr == 'opacity') {
                            domEle.style[attr] = (iCur + iSpeed) / 100 ;
    
                        } else {
                            domEle.style[attr] = iCur + iSpeed + 'px';
                        }
                    }
                    // 所有值到达目标点停止定时器
                    if (bStop) {
                        clearInterval(domEle.timer);
                    }
    
                },60);
            }
    
            function getStyle(dom, attr) {
                if (window.getComputedStyle) {
                    return window.getComputedStyle(dom, null)[attr];
                } else {
                    return dom.currentStyle[attr]
                }
            }
        </script>
    </body>

**多物体多值运动+****回调机制：**

    <body>
        <div style="position: absolute; left: 0; top: 0; width: 50px; height: 50px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
    
        <div style="position: absolute; left: 0; top: 500px; width: 50px; height: 50px; background-color: #f40; opacity: 0.5; margin-bottom: 20px;"> 
        </div>
    
        <script>
            var oDiv = document.getElementsByTagName('div')[0];
            var oDiv2 = document.getElementsByTagName('div')[1];
            var timer = null;
            // width： 50 -> 200; height: 50 -> 200;opacity: 0.5 -> 0.8; left: 0 -> 400; top: 0 -> 200
            var attrObj = {
                width: 200,
                height: 200,
                opacity: 80,        // 扩大100倍
                left: 400,
                top: 150
            }
            oDiv.onmouseenter = function() {
                slowMove(this, attrObj,function() {
                    slowMove(oDiv2, attrObj, function() {
                        alert('Over');
                    })
                });
            }
    
            // 封装多值运动
            function slowMove(domEle, attrObj, callback) {
                clearInterval(domEle.timer);
                var iSpeed = null,
                    iCur = null;
                
                // 给标签添加一个属性
                domEle.timer = setInterval(function() {
                    var bStop = true;   // 停止条件标志
                    for ( var attr in attrObj) {
                        // oapcity扩大100
                        if (attr == 'opacity') {
                            iCur = parseFloat(getStyle(domEle, attr)) * 100 ;
                        } else {
                            iCur = parseInt(getStyle(domEle, attr)) ;
                        }
    
                        iSpeed = (attrObj[attr] - iCur) / 7 ;
                        iSpeed = iSpeed > 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed);
    
                        if (attr == 'opacity') {
                            domEle.style[attr] = (iCur + iSpeed) / 100 ;
    
                        } else {
                            domEle.style[attr] = iCur + iSpeed + 'px';
                        }
                        if (attrObj[attr] != iCur) {
                            bStop = false;          // 有一个没有到达目标点，bStop 为false，不能清理定时器
                        } 
                    }
                    // 所有值到达目标点停止定时器
                    if (bStop) {
                        clearInterval(domEle.timer);
                         // 回调函数执行
                        typeof callback == 'function' && callback();
                    }
                },60);
            }
    
            function getStyle(dom, attr) {
                if (window.getComputedStyle) {
                    return window.getComputedStyle(dom, null)[attr];
                } else {
                    return dom.currentStyle[attr]
                }
            }
        </script>
    </body>







# 加速运动-拖拽实例 

# 案例

## 加速度运动

    <body>
        <div style="width: 100px; height: 100px; position: absolute; left: 0; top: 0; background-color: #f40;"></div>
        <script>
            var oDiv = document.getElementsByTagName('div')[0];
            var timer = null;
            oDiv.onmouseenter = function() {
                quickMove(this, 500);
            }
    
            function quickMove(domELe, target) {
                var a = 2;
                var iSpeed = null;
                var iCur = null;
                timer = setInterval(function() {
                    console.log(iSpeed, domELe.style.left);
                    iSpeed = iSpeed + a;
                    iCur = domELe.offsetLeft;
                    domELe.style.left = iCur + iSpeed +'px';
                },60)
            }
        </script>
    </body>

**弹性运动： **

    <body>
        <div style="width: 100px; height: 100px; position: absolute; left: 0; top: 0; background-color: #f40;"></div>
        <span style="position: absolute; left: 300px; width: 1px; background-color: #ccc; height: 100px;"></span>
        <script>
            var oDiv = document.getElementsByTagName('div')[0];
            var timer = null;
            oDiv.onmouseenter = function() {
                flexMove(this, 300);
            }
    
            function flexMove(domEle, target) {
                var a = 5;
                var iSpeed = 0;
                var iCur = null;
                var u = 0.8;            // 减速
                clearInterval(timer);
                timer = setInterval(function() {
                    a = target > domEle.offsetLeft ? 2 : -2;
                    iSpeed = iSpeed + a;
                    iSpeed *= 0.8;
                    console.log(iSpeed, domEle.style.left);
                    // 近似把速度绝对值<1，看成是0
                    if (Math.abs(iSpeed) < 1 && Math.abs(target - domEle.offsetLeft) < 1) {
                        clearInterval(timer);
                        domEle.style.left = target + 'px';
                    } else {
                        domEle.style.left = domEle.offsetLeft + iSpeed +'px';
                    }
                },30)
            }
        </script>
    </body>



**弹性运动：**

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
            #wrapper {
                margin: 100px auto;
                overflow: hidden;
                width: 400px;
                height: 50px;
                border: 1px solid #ccc;
            }
    
            * {
                margin: 0;
                padding: 0;
            }
            .content {
                position: relative;
                list-style: none;
                width: 600px;
                height: 50px;
            }
            #wrapper .sg {
                float: left;
                width: 98px;
                height: 50px;
                background-color: #f80;
                border: 1px solid #ccc;
            }
            #wrapper .bg {
                position: absolute;
                left: 400px;
                width: 98px;
                height: 50px;
                background-color: #F40;
                border: 1px solid #ccc;
                opacity: 0.5;
            }
        </style>
    </head>
    <body>
        <div id = 'wrapper'>
            <ul class = 'content'>
                <li class="sg"></li>
                <li class="sg"></li>
                <li class="sg"></li>
                <li class="sg"></li>
                <li class="bg"></li>
            </ul>
        </div>
    
        <script>
            var oSgs = document.getElementsByClassName('sg');
            var oBg = document.getElementsByClassName('bg')[0];
            var timer = null;
           
            for (var i = 0; i < oSgs.length; i ++) {
                oSgs[i].onmouseenter = function() {
                    flexMove(oBg, this.offsetLeft);
                }
            }


​    

            function flexMove(domEle, target) {
                var a = 5;
                var iSpeed = 0;
                var iCur = null;
                var u = 0.8;            // 减速
                clearInterval(timer);
    
                timer = setInterval(function() {
                    a = target > domEle.offsetLeft ? 2 : -2;
                    iSpeed = iSpeed + a;
                    iSpeed *= 0.8;
                    console.log(iSpeed, domEle.style.left);
                    // 近似把速度绝对值<1，看成是0
                    if (Math.abs(iSpeed) < 1 && Math.abs(target - domEle.offsetLeft) < 1) {
                        clearInterval(timer);
                        domEle.style.left = target + 'px';
                    } else {
                        domEle.style.left = domEle.offsetLeft + iSpeed +'px';
                    }
                },30)
            }
        </script>
    </body>
    </html>

## 模拟重力场

> 多方向运动+碰撞检测+重力加速度+能量损失

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>模拟重力场</title>
    </head>
    <body>
        <div style="position: absolute; top: 0; left: 0; width: 100px; height: 100px; background-color: #f40;opacity: 0.5;"></div>
        <script>
            var oDiv = document.getElementsByTagName('div')[0];
            oDiv.onmouseenter = function() {
                startMove(this, -6, -208);
            }
    
            //模拟重力场
            function startMove(domEle, iSpeedX, iSpeedY) {
                clearInterval(domEle.timer);
                // 重力加速度
                var g = 3;
                // 移动距离
                var aTop,
                    aLeft;
                // 最大移动距离
                maxWidth = document.documentElement.clientWidth - domEle.clientWidth;
                maxHeight = document.documentElement.clientHeight - domEle.clientHeight;
    
                domEle.timer = setInterval(function() {
                    // 速度
                    iSpeedY += g;
    
                    // 坐标
                    aTop = domEle.offsetTop + iSpeedY;
                    aLeft = domEle.offsetLeft + iSpeedX;
    
                    // 碰撞检测
                    // 速度碰撞后损耗
                    if (aTop >= maxHeight) {
                        iSpeedY *= -1;
                        iSpeedX *= 0.8;
                        iSpeedY *= 0.8;
                        aTop = maxHeight;
                    }
                    if (aTop <= 0) {
                        iSpeedY *= -1;
                        iSpeedX *= 0.8;
                        iSpeedY *= 0.8;
                        aTop = 0;
                    }
                    if (aLeft >= maxWidth) {
                        iSpeedX *= -1;
                        iSpeedX *= 0.8;
                        iSpeedY *= 0.8;
                        aLeft = maxWidth;
                    }
                    if (aLeft <= 0) {
                        iSpeedX *= -1;
                        iSpeedX *= 0.8;
                        iSpeedY *= 0.8;
                        aLeft = 0;
                    }
    
                    // 停止条件
                    iSpeedX = Math.abs(iSpeedX) < 1 ? 0 : iSpeedX;
                    iSpeedY = Math.abs(iSpeedY) < 1 ? 0 : iSpeedY;
                    console.log(iSpeedX,iSpeedY, maxHeight, aTop);
                    if (iSpeedX == 0 && iSpeedY == 0 && aTop == maxHeight) {
                        clearInterval(domEle.timer);
                        console.log('over');
                    }else {
                        domEle.style.top = aTop + 'px';
                        domEle.style.left = aLeft + 'px';
                    }
                },30)
            }
    
        </script>
    </body>
    </html>

## 拖拽实例

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>拖拽实例</title>
    </head>
    <body>
        <div style="position: absolute; top: 0; left: 0; width: 100px; height: 100px; background-color: #f40;opacity: 0.5;"></div>
        <script>
            var oDiv = document.getElementsByTagName('div')[0];
            oDiv.onmousedown = function (e) {
                clearInterval(this.timer);
                // 鼠标按下的起始点
                var startX = e.clientX - this.offsetLeft;
                var startY = e.clientY - this.offsetTop;
                // 保存oDiv
                var _self = this;
    
                // 记录上一次运动坐标
                var lastX = 0;
                var lastY = 0;
                // 速度
                var iSpeedX,
                    iSpeedY;
    
                document.onmousemove = function(e) {
                    var newTop = e.clientY - startY;
                    var newLeft = e.clientX - startX;
                    // 运动轨迹
                    var oSpan = document.createElement('span');
                    oSpan.style.position = 'absolute';
                    oSpan.style.width = '5px';
                    oSpan.style.height = '5px';
                    oSpan.style.backgroundColor = '#FA0';
                    oSpan.style.left = newLeft + 'px';
                    oSpan.style.top = newTop + 'px';
                    document.body.appendChild(oSpan);
    
                    // 运动速度
                    iSpeedX = newLeft - lastX;
                    iSpeedY = newTop - lastY;
                    // 记录上一次运动的位置
                    lastX = newLeft;
                    lastY = newTop;
    
                    _self.style.left = newLeft + 'px';
                    _self.style.top = newTop + 'px';
                }
    
                this.onmouseup = function() {
                    startMove(this, iSpeedX, iSpeedY);
                    document.onmousemove = null;
                    document.onmouseup = null;
                }
            }


​    
​    

            //模拟重力场
            function startMove(domEle, iSpeedX, iSpeedY) {
                clearInterval(domEle.timer);
                // 重力加速度
                var g = 3;
                // 移动距离
                var aTop,
                    aLeft;
                // 最大移动距离
                maxWidth = document.documentElement.clientWidth - domEle.clientWidth;
                maxHeight = document.documentElement.clientHeight - domEle.clientHeight;
    
                domEle.timer = setInterval(function() {
                    // 速度
                    iSpeedY += g;
    
                    // 坐标
                    aTop = domEle.offsetTop + iSpeedY;
                    aLeft = domEle.offsetLeft + iSpeedX;
    
                    // 碰撞检测
                    // 速度碰撞后损耗
                    if (aTop >= maxHeight) {
                        iSpeedY *= -1;
                        iSpeedX *= 0.8;
                        iSpeedY *= 0.8;
                        aTop = maxHeight;
                    }
                    if (aTop <= 0) {
                        iSpeedY *= -1;
                        iSpeedX *= 0.8;
                        iSpeedY *= 0.8;
                        aTop = 0;
                    }
                    if (aLeft >= maxWidth) {
                        iSpeedX *= -1;
                        iSpeedX *= 0.8;
                        iSpeedY *= 0.8;
                        aLeft = maxWidth;
                    }
                    if (aLeft <= 0) {
                        iSpeedX *= -1;
                        iSpeedX *= 0.8;
                        iSpeedY *= 0.8;
                        aLeft = 0;
                    }
    
                    // 停止条件
                    iSpeedX = Math.abs(iSpeedX) < 1 ? 0 : iSpeedX;
                    iSpeedY = Math.abs(iSpeedY) < 1 ? 0 : iSpeedY;
                    console.log(iSpeedX,iSpeedY, maxHeight, aTop);
                    if (iSpeedX == 0 && iSpeedY == 0 && aTop == maxHeight) {
                        clearInterval(domEle.timer);
                        console.log('over');
                    }else {
                        domEle.style.top = aTop + 'px';
                        domEle.style.left = aLeft + 'px';
                    }
                },30)
            }
    
        </script>
    </body>
    </html>

![image.png](../.gitbook/assets/1595032598684-2791724e-8aa5-436a-b1aa-c3660d1643bf.png) 



# 深入数组扩展方法并应用 

# 数组扩展

> ForEach
>
> Filter
>
> Map
>
> Every
>
> Some
>
> Reduce
>
> ReduceRight

## forEach

> 循环执行数组长度的次数。
>
> `Array.prototype.forEach`
>
> forEach参数：（ func， obj)
>
> obj 决定 func里this指向，默认指向window。
>
> func参数： => ele index self  （数组元素、索引、数组本身）

**案例：**

    <body>
        <script>
            var personArr = [
                {name: '王刚', src: './src/img/3.png', des: '颈椎不太好', sex: 'm'},
                {name: '刘金磊', src: './src/img/3.png', des: '颈椎不好', sex: 'm'},
                {name: '刘飞翔', src: './src/img/3.png', des: '颈椎不好', sex: 'm'}];
            
            var obj = {name: 'DUDU'};
    
            personArr.forEach(deal);
            personArr.forEach(deal, obj);
    
            function deal(ele, index, self) {
                console.log(ele, index, self, this);
            }
        </script>
    </body>

![image.png](../.gitbook/assets/1595062789646-09163b00-5f48-4acf-8771-85db6b275f91.png)

**实现forEach：**

    <body>
        <script>
            var personArr = [
                {name: '王刚', src: './src/img/3.png', des: '颈椎不好', sex: 'm'},
                {name: '刘颖', src: './src/img/3.png', des: '颈椎不好', sex: 'f'},
                {name: '王秀英', src: './src/img/3.png', des: '颈椎不好', sex: 'f'},
                {name: '刘金磊', src: './src/img/3.png', des: '颈椎不好', sex: 'm'},
                {name: '刘飞翔', src: './src/img/3.png', des: '颈椎不好', sex: 'm'}];
            var obj = {name: 'DUDU'};
    
            // 实现forEach
            // 目的：数组实例可以调用该方法，要达到循环遍历的作用
            // 参数： (func, obj)。
            // func：实现一系列功能，接收（ele, index, this) 3个参数
            // obj： 决定 func里 this指向。默认window
            Array.prototype.myforEach = function(func , obj) {
                var len = this.length;
                var _obj = arguments[1] != undefined ? arguments[1] : window;
                for ( var i = 0; i < len; i ++) {
                    func.apply(_obj, [this[i], i , this]);
                }
            }
    
            personArr.myforEach(deal, obj);
    
            function deal(ele, index, self) {
                console.log(ele, index, self, this);
            }
        </script>
    </body>

## Filter

> 对数组过滤的作用，基于遍历的。
>
> `Array.prototype.filter`
>
> filter 参数：(func,obj) 
>
> 返回值：返回一个新的数组。
>
> 
>
>
> obj 决定 func里this指向，默认指向window。
>
> func => 参数：ele index self （数组元素、索引、数组本身）
>
> 返回值：true： 保存到数组，false不保存。

    <body>
        <script>
            var personArr = [
                {name: '王刚', src: './src/img/3.png', des: '颈椎不好', sex: 'm'},
                {name: '刘颖', src: './src/img/3.png', des: '颈椎不好', sex: 'f'},
                {name: '王秀英', src: './src/img/3.png', des: '颈椎不好', sex: 'f'},
                {name: '刘金磊', src: './src/img/3.png', des: '颈椎不好', sex: 'm'},
                {name: '刘飞翔', src: './src/img/3.png', des: '颈椎不好', sex: 'm'}];
            var obj = {name: 'DUDU'};
    
            var newArr = personArr.filter(deal, obj);
            console.log(newArr);
    
            function deal(ele, index, self) {
                console.log(this);
                return ele.sex == 'm';      // true:保存到返回值， false：不保存
            }
        </script>
    </body>

![image.png](../.gitbook/assets/1595067853829-f9aeafe3-9bbf-4319-b342-fa29b78e0cd8.png)

实现：myfilter

    <body>
        <script>
            var personArr = [
                {name: '王刚', src: './src/img/3.png', des: '颈椎不好', sex: 'm'},
                {name: '刘颖', src: './src/img/3.png', des: '颈椎不好', sex: 'f'},
                {name: '王秀英', src: './src/img/3.png', des: '颈椎不好', sex: 'f'},
                {name: '刘金磊', src: './src/img/3.png', des: '颈椎不好', sex: 'm'},
                {name: '刘飞翔', src: './src/img/3.png', des: '颈椎不好', sex: 'm'}];
            var obj = {name: 'DUDU'};
            // 实现myFilter
            Array.prototype.myFilter = function(func, obj) {
                var len = this.length;
                var newArr = []
                var _obj = arguments[1] || window;
                for (var i = 0; i < len; i ++) {
                    // func返回值 true 时 push到newArr
                    func.apply(_obj, [this[i], i , this]) && newArr.push(this[i]);
                }
                return newArr;
            }
    
            var newArr = personArr.myFilter(deal, obj);
            console.log(newArr);
    
            function deal(ele, index, self) {
                console.log(this);
                return ele.sex == 'm';      // true:保存到返回值， false：不保存
            }
        </script>
    </body>

## Map

> 映射。
>
> `Array.prototype.map`
>
> map 参数：(func,obj) 
>
> 按照规则返回一个新的数组。
>
> func => 参数：ele index self （数组元素、索引、数组本身）
>
> 返回值：返回值决定新数组的值。

    <body>
        <script>
            var personArr = [
                {name: '王刚', src: './src/img/3.png', des: '颈椎不好', sex: 'm'},
                {name: '刘颖', src: './src/img/3.png', des: '颈椎不好', sex: 'f'},
                {name: '王秀英', src: './src/img/3.png', des: '颈椎不好', sex: 'f'},
                {name: '刘金磊', src: './src/img/3.png', des: '颈椎不好', sex: 'm'},
                {name: '刘飞翔', src: './src/img/3.png', des: '颈椎不好', sex: 'm'}];
            var obj = {name: 'DUDU'};
            var newArr = personArr.map(deal, obj);
            console.log(newArr);
    
            function deal(ele, index, self) {
                console.log(this);
                return 10;     // 返回值决定新数组的值
            }
        </script>
    </body>

![image.png](../.gitbook/assets/1595069938334-2a2958dc-4d9c-4d86-8643-72489913b96b.png)

实现：map

    <body>
        <script>
            var personArr = [
                {name: '王刚', src: './src/img/3.png', des: '颈椎不好', sex: 'm'},
                {name: '刘颖', src: './src/img/3.png', des: '颈椎不好', sex: 'f'},
                {name: '王秀英', src: './src/img/3.png', des: '颈椎不好', sex: 'f'},
                {name: '刘金磊', src: './src/img/3.png', des: '颈椎不好', sex: 'm'},
                {name: '刘飞翔', src: './src/img/3.png', des: '颈椎不好', sex: 'm'}];
            var obj = {name: 'DUDU'};
    
            // 实现myMap
            Array.prototype.myMap = function(func, obj) {
                var len = this.length;
                var arr = [];
                var _obj = arguments[1] || window;
                for ( var i = 0; i < len; i ++) {
                    arr.push(func.apply(_obj,[this[i], i, this]));
                }
                return arr;
            }
            var newArr = personArr.myMap(deal, obj);
            console.log(newArr);
    
            function deal(ele, index, self) {
                console.log(this);
                return ele.name;     // 返回值决定新数组的值
            }
        </script>
    </body>

![image.png](../.gitbook/assets/1595070442623-929dd63d-2c12-4286-8e62-e1c5cd1df5c9.png)

## Every

> 判断数组中的元素是否都符合条件。true，false。

func  true flase 

    <body>
        <script>
            var personArr = [
                {name: '王刚', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 20},
                {name: '刘颖', src: './src/img/3.png', des: '颈椎不好', sex: 'f', age: 30},
                {name: '王秀英', src: './src/img/3.png', des: '颈椎不好', sex: 'f', age: 22},
                {name: '刘金磊', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 40},
                {name: '刘飞翔', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 42}];
            var obj = {name: 'DUDU'};
    
            var flag = personArr.every(function(ele, index, self) {
                console.log(ele.age);
                return ele.age > 18;     // 
            }, obj);
            console.log(flag);
    
            var flag = personArr.every(function(ele, index, self) {
                console.log(ele.age);
                return ele.age > 30;     // 只要有一个为flase 就不继续执行
            }, obj);
            console.log(flag);
        </script>
    </body>

![image.png](../.gitbook/assets/1595071074760-6a61e795-1ed5-483e-9763-ca28146d24a7.png)

实现：every

    <body>
        <script>
            var personArr = [
                {name: '王刚', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 20},
                {name: '刘颖', src: './src/img/3.png', des: '颈椎不好', sex: 'f', age: 30},
                {name: '王秀英', src: './src/img/3.png', des: '颈椎不好', sex: 'f', age: 22},
                {name: '刘金磊', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 40},
                {name: '刘飞翔', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 42}];
            var obj = {name: 'DUDU'};
    
            // 实现myEvery
            Array.prototype.myEvery = function(func, obj) {
                var len = this.length;
                var arr = [];
                var flag = true;
                var _obj = arguments[1] || window;
                for ( var i = 0; i < len; i ++) {
                    if (func.apply(_obj,[this[i], i, this]) == false) {
                        flag = false;
                        break;
                    }
                }
                return flag;
            }
            var flag = personArr.myEvery(function(ele, index, self) {
                console.log(ele.age);
                return ele.age > 18;     // 
            }, obj);
            console.log(flag);
    
            var flag = personArr.myEvery(function(ele, index, self) {
                console.log(ele.age);
                return ele.age > 30;     // 只要有一个为flase 就不继续执行
            }, obj);
            console.log(flag);
        </script>
    </body>

## Some

> 有一个返回true 就返回true。

    <body>
        <script>
            var personArr = [
                {name: '王刚', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 20},
                {name: '刘颖', src: './src/img/3.png', des: '颈椎不好', sex: 'f', age: 30},
                {name: '王秀英', src: './src/img/3.png', des: '颈椎不好', sex: 'f', age: 22},
                {name: '刘金磊', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 40},
                {name: '刘飞翔', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 42}];
            var obj = {name: 'DUDU'};
    
            var flag = personArr.some(function(ele, index, self) {
                console.log(ele.age);
                return ele.age > 30;     // 只要有一个为true 就返回true
            }, obj);
            console.log(flag);
        </script>
    </body>

![image.png](../.gitbook/assets/1595071755443-effbb55f-76da-41f4-8d8d-5c62d0b0899b.png)

    <body>
        <script>
            var personArr = [
                {name: '王刚', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 20},
                {name: '刘颖', src: './src/img/3.png', des: '颈椎不好', sex: 'f', age: 30},
                {name: '王秀英', src: './src/img/3.png', des: '颈椎不好', sex: 'f', age: 22},
                {name: '刘金磊', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 40},
                {name: '刘飞翔', src: './src/img/3.png', des: '颈椎不好', sex: 'm', age: 42}];
            var obj = {name: 'DUDU'};
    
            // 实现mySome
            Array.prototype.mySome = function(func, obj) {
                var len = this.length;
                var arr = [];
                var flag = false;
                var _obj = arguments[1] || window;
                for ( var i = 0; i < len; i ++) {
                    if (func.apply(_obj,[this[i], i, this]) == true) {
                        flag = true;
                    }
                }
                return flag;
            }
    
            var flag = personArr.mySome(function(ele, index, self) {
                console.log(ele.age);
                return ele.age > 30;     // 只要有一个为true 就返回true
            }, obj);
            console.log(flag);
        </script>
    </body>

## Reduce、ReduceRight

> 从左向右遍历  
>
> 从右向左遍历
>
> `Array.prototype.reduce`
>
> 参数：(func, initialValue)
>
> func参数：(prevValue, icurValue, index, self)
>
> 返回值：决定下一次 prevValue的值。

不支持改变this。

**案例：**cookieStr -->cookieObj

    <body>
        <script>
            var cookieStr = '"BAIDUID=1D4F383BF90883622D2454AFB9E4A69F:FG=1; BIDUPSID=1D4F383BF90883622D2454AFB9E4A69F; PSTM=1563282652; sug=3; ORIGIN=0; bdime=0; BD_UPN=123253; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BDSFRCVID=1XkOJeC62uJVlSRrBgd4bVazn2K4CxJTH6aoUclMZv0XeNKzBiC5EG0PSM8g0KubwTWCogKK3gOTH6KF_2uxOjjg8UtVJeC6EG0Ptf8g0f5; H_BDCLCKID_SF=tJFjoIIyJDL3bKD9Kb-_-P4DeNuqBxRZ5mAqot3t3DJaMP_Rhpt5XfDr0n6LBMPOtG6naIQqah75jMj1j-6DW4FJh4ba0J343bRT04Py5KJvfJochUO_hP-UyNbMWh37JNRlMKoaMp78jR093JO4y4Ldj4oxJpOJ5JbMopCafD_bMKD4DT-5ePFyMMoBa6LXKKOLV-IbXh7keq8CDR5R0UrQylKe2MjqBmrTbMcEL4cKMMj2y5jHhP3-QMOAWDrIamAL3Cnh0JOpsIJMhnAWbT8U5f5wbTJ-aKviaKOjBMb1MMJDBT5h2M4qMxtOLR3pWDTm_q5TtUJMeCnTD-Dhe6jXjG88tTLqf5vfL5rVbnOHqP-k-PI3DJ8fXP6-hnjy3b7dKfom-qosSx3P34LaD40AWHDfaq3RymJ4L4JCblO4SM3EqfO4XRkD-toxJpOJ-K-JW4cIKfjRHUnvbURvD--g3-AqBM5dtjTO2bc_5KnlfMQ_bf--QfbQ0hOhqP-jBRIEoKtaJIIBhDIrh-nJhICDMfTMtjKOHD7XVhuMXh7keq8CDRok34A90l5Gb5jDBmrTbhjjWKbTJhc2y5jHhPDbBUO4-MvMtDnWXqoV0K5psIJM0UFWbT8U5f5fLpbmaKviaKOjBMb1MMJDBT5h2M4qMxtOLR3pWDTm_q5TtUJMeCnTD-Dhe6JQjH88q6_8fKJy0bA8aRT_eILCeKTjh6nLWMR9BtQmJJrtafQsLMoKER3gj-54-JIHD44J3bvZQg-q3R7GKbRYo4LxW-oFynIYMt-t0x-jLN7uVn0MW-5DfUb5LPnJyUnybPnnBT5i3H8HL4nv2JcJbM5m3x6qLTKkQN3T-PKO5bRh_CcJ-J8XhI0mjT7P; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; BD_CK_SAM=1; PSINO=7; BD_HOME=1; COOKIE_SESSION=110123_12_8_4_24_39_0_4_4_6_1_8_326045_0_3_7_1595057462_1594827937_1595057459%7C9%2396527_362_1594827930%7C9; H_PS_PSSID=1465_31660_32046_32231_32245_32115_31322; sugstore=1"'
            // cookieStr字符串 --> Obj
            function parseCookieStr (str) {
                var obj = {};
                var cookieArr = str.split(';');
                return cookieArr.reduce(function(prevValue, icurValue, index, self) {
                    var arr = icurValue.split('=');
                    prevValue[arr[0]] = arr[1];
                    return prevValue;
                }, obj)
            }
    
            var cookieObj = parseCookieStr(cookieStr);
     </script>
    </body>

实现：reduce

    <body>
        <script>
            var cookieStr = '"BAIDUID=1D4F383BF90883622D2454AFB9E4A69F:FG=1; BIDUPSID=1D4F383BF90883622D2454AFB9E4A69F; PSTM=1563282652; sug=3; ORIGIN=0; bdime=0; BD_UPN=123253; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BDSFRCVID=1XkOJeC62uJVlSRrBgd4bVazn2K4CxJTH6aoUclMZv0XeNKzBiC5EG0PSM8g0KubwTWCogKK3gOTH6KF_2uxOjjg8UtVJeC6EG0Ptf8g0f5; H_BDCLCKID_SF=tJFjoIIyJDL3bKD9Kb-_-P4DeNuqBxRZ5mAqot3t3DJaMP_Rhpt5XfDr0n6LBMPOtG6naIQqah75jMj1j-6DW4FJh4ba0J343bRT04Py5KJvfJochUO_hP-UyNbMWh37JNRlMKoaMp78jR093JO4y4Ldj4oxJpOJ5JbMopCafD_bMKD4DT-5ePFyMMoBa6LXKKOLV-IbXh7keq8CDR5R0UrQylKe2MjqBmrTbMcEL4cKMMj2y5jHhP3-QMOAWDrIamAL3Cnh0JOpsIJMhnAWbT8U5f5wbTJ-aKviaKOjBMb1MMJDBT5h2M4qMxtOLR3pWDTm_q5TtUJMeCnTD-Dhe6jXjG88tTLqf5vfL5rVbnOHqP-k-PI3DJ8fXP6-hnjy3b7dKfom-qosSx3P34LaD40AWHDfaq3RymJ4L4JCblO4SM3EqfO4XRkD-toxJpOJ-K-JW4cIKfjRHUnvbURvD--g3-AqBM5dtjTO2bc_5KnlfMQ_bf--QfbQ0hOhqP-jBRIEoKtaJIIBhDIrh-nJhICDMfTMtjKOHD7XVhuMXh7keq8CDRok34A90l5Gb5jDBmrTbhjjWKbTJhc2y5jHhPDbBUO4-MvMtDnWXqoV0K5psIJM0UFWbT8U5f5fLpbmaKviaKOjBMb1MMJDBT5h2M4qMxtOLR3pWDTm_q5TtUJMeCnTD-Dhe6JQjH88q6_8fKJy0bA8aRT_eILCeKTjh6nLWMR9BtQmJJrtafQsLMoKER3gj-54-JIHD44J3bvZQg-q3R7GKbRYo4LxW-oFynIYMt-t0x-jLN7uVn0MW-5DfUb5LPnJyUnybPnnBT5i3H8HL4nv2JcJbM5m3x6qLTKkQN3T-PKO5bRh_CcJ-J8XhI0mjT7P; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; BD_CK_SAM=1; PSINO=7; BD_HOME=1; COOKIE_SESSION=110123_12_8_4_24_39_0_4_4_6_1_8_326045_0_3_7_1595057462_1594827937_1595057459%7C9%2396527_362_1594827930%7C9; H_PS_PSSID=1465_31660_32046_32231_32245_32115_31322; sugstore=1"'
            // 封装myReduce(func, initialValue, obj)
            // func(prevValue, icurValue, index, self)
            Array.prototype.myReduce = function(func, initiaValue, obj) {
                var _obj = arguments[2] || window;
                var nextValue = initiaValue;
                var len = this.length;
                for ( var i = 0; i < len; i ++) {
                    
                    nextValue = func.apply(_obj, [nextValue, this[i], i, this]);
                }
                return nextValue;
            }


​    

            // cookieStr字符串 --> Obj
            function parseCookieStr (str) {
                var obj = {};
                var cookieArr = str.split(';');
                return cookieArr.myReduce(function(prevValue, icurValue, index, self) {
                    var arr = icurValue.split('=');
                    prevValue[arr[0]] = arr[1];
                    return prevValue;
                }, obj)
            }
    
            var cookieObj = parseCookieStr(cookieStr);
     </script>
    </body>

